あなたはPythonおよびPyomo最適化モデルの専門家です。
以下の制約条件・データを基に、1週間分の献立最適化問題のPyomoモデル（Pythonコード）を**コードのみ**出力してください。
説明文や余計なコメント、日本語文章は含めず、Pyomoで実行可能なPythonコードとしてのみ返答してください。

目標
１週間分の一人分の夕食の献立を作成

目的関数
献立に使用する食材の種類を最小化する

制約条件
優先順位１：献立に含まれる栄養素量はNutritionalTargetの範囲に収めること。どのレコードを参照するかはuserInfoによる
優先順位２：ItemWeightのitemNameに格納されている食材は１食の献立に使用する量を該当レコードのweightsの倍数にすること
優先順位３：１週間の献立で各レシピは１回のみ使用すること。ただし、recipeTitle：白米のみ６回まで使用できる。

データ
・各レシピに使用されている食材はRecipeItemを参照すること
・各レシピに含まれている栄養素量はRecipeNutritionを参照すること
・ItemEqualのitemNameに格納されている食材は該当レコードのequalsに格納されている食材と同一の食材として扱うこと
・どの料理が下記で示す主食等に当たるかはRecipeのdataのkind1を参照すること
・どの料理が下記で示すご飯もの等に当たるかはRecipeのdataのkind2を参照すること
・NutritonalTargetのnutritonalsの項目は項目名が「栄養素名_上限」や「栄養素名_下限」の場合その範囲内に収めるように設定する
・NutritonalTargetのnutritonalsの項目は項目名が「栄養素名」の場合その数値を超えるようにするが、栄養素名がカロリーの場合のみ数値の±10%に収まるように設定する
・NutritionalTargetのnutritionalsの項目のうち、たんぱく質_下限、たんぱく質_上限、脂質_下限、脂質_上限、炭水化物_下限、炭水化物_上限は単位がRecipeNutritonのnutritionsと違うため以下のように直す。
　・たんぱく質　＝　カロリー＊(たんぱく質_下orたんぱく質_上限)/400
　・脂質　＝　カロリー＊(脂質_下限or脂質_上限)/900
　・たんぱく質　＝　カロリー＊(炭水化物_下限or炭水化物_上限)/400
・ソルバーでの献立作成の際、作成された献立は主食はstaple、主菜はmain、汁物はsoup、副菜はsideという項目名で格納できるようにする
・Recipe、RecipeItem、RecipeNutritionの主キーはrecipeId、NutritonalTargetの主キーはtargetId、ItemWeight、ItemEqualの主キーはitemNameとする
・しかし、userInfoのtargetIdフィールドは一見本質的な意味を持たないのでAPI生成コードではキーアクセスや利用を避けてください
・userInfo（ユーザー情報）はtargetIdを持たず、NutritionalTarget.userInfoを属性一致で検索する設計です
・１食の献立は主食・主菜・副菜・汁物が１品ずつの計４品からなるが、主食がご飯もの・パスタの場合は主食・副菜・汁物の計３品となる
・Setを作成する際は、必ずID一覧リストやdict.keys()を使ってください

ソルバー
・PyomoのソルバーはCBC（solver = SolverFactory('cbc', executable=...')）で出力してください

Pyomoへの出力
・Pyomoでそのままコピーして使用できるPythonコード
・純粋なPythonコードのみを出力して、Markdownや説明文・コメントなどは含めないでください
・Pyomo変数定義時は、下記の約束を守ってください。
　・domain=... は必ず1度だけ、バイナリ変数・連続変数など型だけ指定し、集合/リストはdomainに入れない。
　・インデックス集合はpyo.Var(インデックス1, インデックス2, ..., domain=...)の形で指定。
　・「主食/主菜/汁物/副菜」など区分を変数に格納する場合も、曜日×レシピの組み合わせ＋domain=pyo.Binary、としてください。
　　（正例）model.staple = pyo.Var(model.Days, model.Recipes, domain=pyo.Binary)
・このルールに合わないPyomoコード（domainの二重指定など）は出力しないでください。
・Pyomoの制約(rule)関数内でreturnする値は必ずPyomoの等式/不等式（例: sum(x[i] for i in S) == 1 など）にしてください。
・絶対に「return True」や「return False」だけを返してはいけません。単なるブール値は返さず、Pyomo式としての比較・等式を返してください。
    ・誤った例：（禁止）
        def rule(...):
            if ...: return True
    ・正しい例：
        def rule(...):
            return sum(x[i] for i in S) == 1
・もし対象集合が空の場合、rule関数はConstraint.InfeasibleやConstraint.Skipを返してください。絶対にTrueやFalseの布値は返さないでください。
・Pyomoモデルの制約(rule)関数では、絶対に if や while などの条件式で Pyomo変数や計算式 (Var, Param, Expression) を使わないでください。
・if や while、and/or などの条件判定は Pythonの普通の変数や定数のみで行ってください。
・変数や式の比較は必ず return 文で Pyomo式として記述してください。例: return sum(x[i] for i in S) <= 3
・辞書データ型は ['key'] 形式でアクセスし、.key 形式は一切使わないでください。
・不要な場合や制約適用外の場合は pyo.Constraint.Skip または pyo.Constraint.Infeasible を明示的に return してください。
・このルールに反するPyomoコードは絶対に生成しないでください。
・以下の構文は禁止です：
　・(a <= expression <= b) のような両側不等式
　・if, while でVarや式を条件に使用する
　・return True または return False
　正しい構文例：
　return pyo.inequality(lower, expression, upper)
・正しい制約定義例：
　def rule(model, i):
   　 expr = sum(model.x[i, j] for j in model.J)
    　return pyo.inequality(100, expr, 200)
　model.ConstraintName = pyo.Constraint(model.I, rule=rule)
・注意：Pyomoの式はPythonのbool値ではなく、数式式(Algebraic Expression)です。
　したがって if model.x >= 1 のような評価は避け、Constraintで等式/不等式をreturnしてください。


