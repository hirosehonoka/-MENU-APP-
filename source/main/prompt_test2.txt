あなたはPythonおよびPyomo最適化モデルの専門家です。
以下の制約条件・データを基に、1週間分の献立最適化問題のPyomoモデル（Pythonコード）で実行可能な**コードのみ**出力してください。
説明文や余計なコメント、日本語文章は含めず、Pyomoで実行可能なPythonコードとしてのみ返答してください。

目標
１週間分の一人分の夕食の献立を作成

目的関数
献立に使用する食材の種類を最小化する

制約条件
優先順位１：献立に含まれる栄養素量はNutritionalTargetの範囲に収めること。どのレコードを参照するかはuserInfoによる
優先順位２：ユーザの入力の項目で使用する食材と量として指定されている食材と量は必ず使い切ること
優先順位３：ItemWeightのitemNameに格納されている食材は１食の献立に使用する量を該当レコードのweightsの倍数にすること
優先順位４：１週間の献立で各レシピは１回のみ使用すること。ただし、recipeTitle：白米のみ６回まで使用できる。

データ
・各レシピに使用されている食材はRecipeItemを参照すること
・各レシピに含まれている栄養素量はRecipeNutritionを参照すること
・ItemEqualのitemNameに格納されている食材は該当レコードのequalsに格納されている食材と同一の食材として扱うこと
・どの料理が下記で示す主食等に当たるかはRecipeのdataのkind1を参照すること
・どの料理が下記で示すご飯もの等に当たるかはRecipeのdataのkind2を参照すること
・NutritonalTargetのnutritonalsの項目は項目名が「栄養素名_上限」や「栄養素名_下限」の場合その範囲内に収めるように設定する
・NutritonalTargetのnutritonalsの項目は項目名が「栄養素名」の場合その数値を超えるようにするが、栄養素名がカロリーの場合のみ数値の±10%に収まるように設定する
・NutritionalTargetのnutritionalsの項目のうち、たんぱく質_下限、たんぱく質_上限、脂質_下限、脂質_上限、炭水化物_下限、炭水化物_上限は単位がRecipeNutritonのnutritionsと違うため以下のように直す。
　・たんぱく質　＝　カロリー＊(たんぱく質_下orたんぱく質_上限)/400
　・脂質　＝　カロリー＊(脂質_下限or脂質_上限)/900
　・たんぱく質　＝　カロリー＊(炭水化物_下限or炭水化物_上限)/400
・ソルバーでの献立作成の際、作成された献立は主食はstaple、主菜はmain、汁物はsoup、副菜はsideという項目名で格納できるようにする
・Recipe、RecipeItem、RecipeNutritionの主キーはrecipeId、NutritonalTargetの主キーはtargetId、ItemWeight、ItemEqualの主キーはitemNameとする
・しかし、userInfoのtargetIdフィールドは一見本質的な意味を持たないのでAPI生成コードではキーアクセスや利用を避けてください
・userInfo（ユーザー情報）はtargetIdを持たず、NutritionalTarget.userInfoを属性一致で検索する設計です
・１食の献立は主食・主菜・副菜・汁物が１品ずつの計４品からなるが、主食がご飯もの・パスタの場合は主食・副菜・汁物の計３品となる
・Setを作成する際は、必ずID一覧リストやdict.keys()を使ってください

ユーザの入力
・以下の食材は表記揺れ(カタカナ、ひらがな、漢字)にも対応できるようにしてください
・使用する食材と量(g)：
{{指定食材}}

ソルバー
・PyomoのソルバーはCBC（solver = SolverFactory('cbc', executable=...')）で出力してください

Pyomoへの出力
・出力形式
　Pyomoでそのままコピー実行できる純粋なPythonコードのみを生成すること。
　Markdown記法・コメント・日本語や説明文は一切含めない。
・変数定義（Var）
　・domain=は型（例:  pyo.Binary、 pyo.NonNegativeReals など）だけを1回指定する。
　・インデックスセットは pyo.Var(集合1, 集合2, ..., domain=...) の形式で指定する。
　・主食・主菜・汁物・副菜など変数もの (曜日 × レシピ) 組で定義する。
　　例：model.staple = pyo.Var(model.Days, model.Recipes, domain=pyo.Binary)
・定義（制約）
　・ルール関数では return 値をPyomo式の等式または決意する。
　　例：return sum(x[i] for i in S) == 1
　・return True や return False は使用禁止。
　・Pyomo変数・式を  ・if 等 の論理条件には使わない。条件分岐はPythonの静的定数だけを対象とする。whileand/or
　・比較式は return 内でPyomo式として直接通じる。
　　例：return sum(x[i] for i in S) <= 3
　・問題適用外のケースではまたはを pyo.Constraint.Skip 理解 pyo.Constraint.Infeasible 的に返します。
　・範囲はPython比較式を使わず pyo.inequality(lower, expr, upper) に置きます。
・データアクセス
　・辞書のアクセスは dict['key'] 記法のみ使用する（.key形式は禁止）。
　・Setは dict.keys() またはリストIDから作成します。
　　例：model.Recipes = pyo.Set(initialize=recipe_dict.keys())
・モデル定義と構文慣例
　・pyo を名前空間として使用（import pyomo.environ as pyo）。
　・モデルは pyo.ConcreteModel() で定義する。
　・ひたすら・パラメータ・変数の命名はPEP 8準拠のスネークケースに統一。
　・すべての要素はPython的に解釈可能な構文・スコープで。